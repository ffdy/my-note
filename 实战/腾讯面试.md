# 逆向

## IDA不能F5的可能问题

- 动态解密
- 栈指针错误
- junkcode，未能正确识别代码和数据
- call调用错误,未能成功解析参数位置和个数
- F5会自动删除其认为不可能到达的死代码，比如异常代码

## switch case的实现方式

- case的值相差较小可以直接用类似数组下标的跳转表实现
- 相差过大又没有规律可能会采用二分查找



## 交叉引用显示没有结果，可能原因

- 加花

- smc      

  上述原因：函数就不能create function，



## 特殊编译器r8寄存器传参，如何让F5生效

更改IDA函数调用方式



## 反调试

### Linux

[link0](https://blog.csdn.net/earbao/article/details/53933238)

#### ptrace自身进程

在同一时间，进程最多只能被一个调试器进行调试

于是我们可以通过调试进程自身来判断是否已经有其他调试器存在

#### 检查父进程名称

通常我们使用gdb调试时，是通过`gdb <TARGET>`，而这种方式是启动gdb，fork出子进程后执行目标二进制文件

因此二进制文件的父进程即为调试器，可以检查父进程名称来判断是否是由调试器fork

#### alarm

设置程序最大运行时间

#### 检查进程运行状态

使用gdb attach到目标进程进行调试后,被调试进程的父进程便不是调试器了,检查/proc/self/status文件,进程状态由sleeping变为tracing stop，TracerPid也由0变为非0的数，即调试器的PID



### Windows

[link1](https://www.52pojie.cn/forum.php?mod=viewthread&tid=271854&page=1&&tdsourcetag=s_pcqq_aiomsg)

[link2](https://www.cnblogs.com/blueprincess/p/3655626.html)

#### Windows API

`IsDebuggerPresent`，`CheckRemoteDebuggerPresent`，`NtQueryInformationProcess`

第一个修改返回结果

第二个改变第二个参数(判断是否再调试)

第三个修改第二个参数（进程信息）

#### 手动检测数据

##### 查询进程PEB(进程环境块)的BeingDebugger(偏移0x2)标志位

进程被调试器所附加时，操作系统会自动设置这个标志位

##### 查询进程PEB(fs:[0x30])的NtGlobal(偏移0x68)标志位

由于调试器中启动进程与正常模式下启动进程有些不同，所以它们创建内存堆的方式也不同，系统使用PEB结构偏移量0x68处的一个未公开位置，来决定如何创建堆结构。如果这个位置的值为0x70，我们就知道进程正运行在调试器中。

##### 触发异常

首先进程使用`SetUnhandledExceptionFilter`函数注册一个未处理异常处理函数A，如果进程没有被调试的话，那么触发一个未处理异常，会导致操作系统将控制权交给之前注册的函数A；如果进程被调试的话，那么这个未处理异常会被调试器捕捉，原先的A函数就没有机会执行了

##### 调用DeleteFiber函数

如果给DeleteFiber函数传递一个无效参数的话，它除了会抛出一个异常意外，还会将进程的`LastError`值设置为具体出错原因的代号

但是，如果进程正在被调试，`LastError`值会被修改，因此如果调试器绕过了上面的异常，还可以验证`LastError`值是否被修改来检测调试器





### OD为什么可以绕过反调试







### 如何对抗OD的反反调试







### 通用绕过time检测的方法







## ollvm的原理





### 如何去掉控制流平坦化









## 静态链接的程序，符号没了，如何解决









## 除法优化





## 一个程序是虚拟机解释器，有什么好方法







## pyc文件逆向

### 换掉opcode以后？



### 换掉的opcode已经有了，如何换回去









## windows上C语言调用约定

> 谁来开辟栈空间

**IDA实际调试，C++类**

- `cdecl`，函数外平栈，例如`printf`

  栈空间的变化

```assembly
push 1
push 2
call function
add esp,8
```

- `stdcall`，函数内平栈
- `fastcall`，和`stdcall`类似（存疑）
  1. 函数的第一个和第二个DWORD参数(或者更小的)，通过`ecx`和`edx`传递，其他参数从右往左压栈
  2. 函数内平栈
  3. 函数名修改规则同`stdcall`
- `thiscall`
  1. 是唯一一个不能明确指明的函数修饰，因为`thiscall`不是关键字，它是C++类成员函数缺省的调用约定，由于成员函数调用还有一个`this`指针，因此必须特殊处理
  2. 函数从右向左入栈
  3. 如果参数个数确定，`this`指针通过`ecx`传递给被调用者；如果参数个数不定，`this`指针在所有参数入栈后被压入堆栈
  4. 对于参数个数不定的，调用者清理堆栈；否则函数自身清理堆栈
  5. ！！！！！！！返回对象，和this的位置关系
- `naked call`



### WINAPI调用约定？

就是`__stdcall`   ？吗？



## linux上有区别吗？cdecl是怎么传的

> windows linux默认调用约定？
>
> gcc vc的默认
>
> ？
>
> 加密与解密看看





## 32位平台如何返回一个64位整数

### 返回一个结构体和类？





## windows上PEB(TEB)的概念

**TEB(Thread Environment Block)**和**PEB(Process Environment Block)**分别储存与**线程和进程**相关的内容

> TEB 线程环境信息块
>
> PEB 进程环境信息块

**TEB**结构一般位于`fs:[0]`的位置，**TEB**结构偏移`0x30`的位置给出了其对应的**PEB**地址

再看看**PEB**的结构，偏移`0x02`的位置有一个`BeingDebugged`的标志位，用于判断程序是否在被调试；此外在偏移`0x68`的`NtGlobalFlag`同样可以用于判断



> `PEB`的`0x18`处给了堆的地址，其中`0x0C`处的`HeapFlags`和`0x10`处的`ForceFlags`也可以用来检测调试
>
> `HeapFlags`的正常值为2
>
> `ForceFlags`的正常值为0



## 对称加密

### Feistel网络



### AES实际使用

难道就是明文传进来一块一块加密出去？





## 为什么hash难碰撞





## hash长度拓展





## MD5中输入翻转了一个bit，输出会怎么变





## linux延迟绑定机制



### 加载完地址就定下，如何实现？

不要延迟绑定的意思吧



### GOT不能写，为什么还能延迟绑定？





## stack canary

fs:0x28？

### fs是什么





## C语言结构体

### 字节对齐

char对齐为1，int为4，编译器默认最小对齐比如为4，那么就会占8个字节

但是编译器参数可以改，比如改成1，就是占5个字节

```C

struct{
    char c1;
    int a;
    char c2;
};	// sizeof == 12

struct{
    char c1;
    char c2;
    int a;
}	// sizeof == 8
```

编译器不会为了省内存而把前者的char c2提到int前



### 位域概念、作用

**位域(bit field)**，也叫**位段**，形如：

```C
struct data {
	char c : 5;
	int a : 24;
	unsigned char : 6;	//无名位域，占6位
};
```



举个例子，这样的结构体只占1字节

```C
struct data {
	char c1 : 4;
	char c2 : 4;
};	// sizeof == 1
```



也可以有意使某个位域从**下一单元**开始：

```C
struct data {
	char c1 : 4;
	char : 0;
	char c2 : 4;
};	// sizeof == 2
```

无名位域仅用于填充或调整位置，不能被访问





**一个位域必须存储在同一个单元中，不能跨两个单元，比如char c1:2; char c2:4**

```C
struct data {
	char c1 : 4;
	char c2 : 5;
	char c3 : 6;
};	// sizeof == 3
```



几个注意点：

- 不能对位域进行**取地址**操作
- 若位域的二进制位数为0，这个位域必须是无名位域，下一个位域从下一个存储单元开始存放
- 若位域出现在表达式中，则自动进行类型提升
- 对位域赋值最好不要超过它能表示的最大范围，可能会造成奇怪的结果

> 整个位域结构体的大小为其最宽基本类型成员大小的整数倍
>
> 这句话**不对**，vs中可以#pragma pack(1) 设置默认最小对齐数







## windows消息机制

一道逆向题：

发现`success`是消息参数0x40B的响应，若是找到发消息的源发地，估计算法就在附近了

先去IDA->import窗口找`SendMessage`但是没找到，接着还有`PostMessage`，找到了







## 如何在C语言main函数之前调用自定义初始化函数



### linux下elf这些函数存在哪里

load段？





## ELF文件最少要那些信息才能跑起来



## ELF:program table & section table

一个segment，一个section

这两个去掉哪个还是可以运行的






# C++

## 第三方库(boost)逆向障碍



## g++编译器：虚表初始化



## boost库静态链接，符号被抹除，如何识别常见函数、一些模板类



## 一个类继承2个虚基类：布局



## typeid

先了解一些`RTTI(Run-Time) Type Identification`运行时类型识别

它使程序能够获取由基类指针或引用所指向对象的实际派生类型，为了支持RTTI，C++提供了`dynamic_cast`和`typeid`

`typeid`是C++关键字之一，等同于`sizeof`这类的操作符

- 如果表达式的类型是**类类型**，并且包含虚函数，则typeid返回表达式的动态类型，需要运行时计算
- 否则，typeid返回表达式的静态类型，编译时就可以计算



`typeid(a).name()`，其中a是一个类，name()函数返回一个C-style字符串





## linux虚拟地址如何映射到物理地址



## NX原理：是 谁 设置页不可执行



## 右值引用

临时值：不具名的**纯右值**

> 区分左值和右值：能**取地址**则为左值，反之为右值

C++11中，所有值必属于**左值、将亡值、纯右值**之一

关键是**将亡值**，比如将要被移动的对象、T&&函数返回值、`std::move`返回值、转换为`T&&`的类型的转换函数的返回值等

`T&& k = getVar();`	表达式结束后，函数产生的临时值不会被销毁，而是被**续命**，它的生命周期将通过右值引用得以延续，和变量k的生命周期一样长

> 常量左值引用是一个**万能**的引用类型

注意，`const A& a = GetA();`必须加上`const`

而`A& a = GetA();`会报一个编译错误，因为**非常量左值引用只能接受左值**



右值引用类型的变量，有可能是左值也有可能是右值

`T&&`表示的值类型**不确定**，这就是一个特点

`T&& t`在发生自动类型推断时，它是**未定的引用类型(universal references)**



>  **移动构造函数**，将指针的**所有者**转移到了另一个对象，同时将原先的指针置为空

C++11 `std::move`可以**将左值转换为右值**，从而方便地应用移动语义，它将对象资源的所有权转移到另一个对象

使用`std::move`几乎没有是任何代价，将左值引用变成右值引用，然后应用**移动语义**，调用**移动构造函数**，避免拷贝



`std::forward`按照参数的**实际类型**转发

> 右值引用`T&&`是一个`universal references`，可以接受左值或者右值，正是这个特性让它适合作为一个**参数的路由**，然后通过`std::forward`按照参数的实际类型去匹配对应的重载函数，最终实现**完美转发**





## NULL和nullptr的区别

```C
#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
        #define NULL ((void *)0)
    #endif
#endif
```

NULL就是一个简单的0,但是如果函数要传一个指针，而我们却传入了int的版本，会导致错误

而传入`nullptr`即可，因为C++规定nullptr可以转换为指针类型，而且是`cv void*`



还有就是模板匹配的问题





## C++类 有没有static的区别

重学！！！





## C++引用和指针有什么区别



### 指针和引用传参时的区别





## 如何将左值引用转换为右值引用





## auto的作用



## lambda怎么写怎么用



## C++中强制类型转换的方法

### dynamic(static)_cast的区别





## C++的四种继承方法





## C++智能指针

### 这些指针使用起来会有什么问题



### 函数参数传一个shared_ptr的问题

资源泄露之外？更严重的问题？



## 为什么STL的快排比我手写的快

小规模，插入排序



## C程序：从源代码变成可执行程序的过程

就是编译过程有哪些步骤













# 操作系统相关

## linux看哪个端口被哪个进程占用









## linux和windows的系统调用约定



## windows的shellcode















<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE4MTAwODg0NzFdfQ==
-->