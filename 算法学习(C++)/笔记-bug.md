# 最大权闭合子图

构造模型时一定保证最小割只会是简单割，即是保证只进行放弃收益和承担代价两种选择。因为最后的总收益=总权值（所有能够得到的收益）-割（放弃的收益和承担的代价之和），所以最大的收益只会出现在割为最小割时。                                                                                                           

# 对偶图

原图内部的建点方式是统一的，但原图外部的建点方式却是因题而异的，大多时候外部需要建多个点。

# 条件收益

图中的每个点表示一个条件，但是无法直接赋予每个点权值使得一种割表示一种方案。

在选取方程的一组特解时，注意到方程是轮换对称的形式，所以就利用下标来分配值，常数平均分配，就巧妙地得出了一组美妙的特解。

全幺模？充分必要条件？

# 线性规划转网络流

将每个等式当做流量平衡条件（有待学习）。

# 滚动数组

牢记滚动数组的每一层必须要**初始化**。

# 矩形经典问题

矩形内最大高度差（单调队列），矩形内最大正方形（单调队列加二分），最大全1矩形（懒算法或悬线法），最大权值和子矩形（分割加继承优化为n3）。

# 二分图匹配

选取较小点集进行枚举会使时间复杂度更优，但并非一定要选取较小点集。

# 位运算

位运算的问题都要拆成31个子问题对应31位。

# 快速排序

为了使指针最多错开一位，判定条件绝对不能加=，此时就必须先移动再判定否则指针无法移动，指针也因此要向外拓展一位，后移动的指针就作为分治的界限。

# 路径覆盖问题

考虑一个点无论在哪条路径上都最多只有一条出边和一条入边，换而言之一个点作为出发点只能与一个目标点匹配，作为目标点只能与一个出发点匹配，此时即可拆点转化为二分图。

# 进制类问题

有些数位DP和进制类问题是相同的，比如不能出现某一数字。

### 负数取模

$$
-13 \equiv-1(mod -2)
$$
这是计算机的运算结果，说明减去的那个数不是第一个-13小的-2的倍数（-14），而是第一个比-13距离0更近的-2的倍数（-12）
$$
-13=-12+-1=6*-2^1+-1*-2^0
$$
这时就需要人为地去改变这个计算结果
$$
-13=-14+1=7*-2^1+1*-2^0
$$

### 小数部分

首先将小数部分完全转换为十进制的分数（对于循环小数的处理要麻烦一些），保存分子$a$和分母$b$。

假设要转换为T进制，则是不断地用$\dfrac{a}{b}\div \dfrac{1}{T}$，然后商为当前位的系数，余数部分再用于计算下一位，重复此操作直到$a=0$或出现循环节为止

# 树形背包总结

### 关于扩充容量问题

目的是为了降低时间复杂度，避免过多的无用转移。

可以将其理解为，随着枚举到第j个子节点，f[i]表示前j个子节点树以及根节点组成的树所能得到的最优状态，那么每加入一个新的子节点树，都可以用目前已有的前j-1个子节点树以及根节点组成的树所能得到的最优状态和这个新子节点树中已处理好的最优状态去更新整个子树的状态。这也是为什么要先前往下层，先处理出一个子节点的所有状态再把它加入的原因。

### 关于使用辅助数组的问题

由目前做题的经验来看，是否使用辅助数组是与问题有关的。例如在**有限电视网**和**贪吃的九头蛇**中，前者的一些子树可以被删掉，因为可以选择不要该**子树的贡献**（当子树的贡献为负时），而后者则必须要**所有点的贡献**。进一步讲，本质区别是在使用每个子节点转移时答案数组要保存的是**前**cnt个子树中若干个子树的贡献，还是**前**cnt个子树中所有子树的贡献，这样的区别会在某些子树造成负贡献时使答案不一样，前者会直接**放弃该子树**，而后者依旧会**接受负贡献**。再进一步，只需考虑转移**是否接受负贡献。**

# KMP与AC自动机总结

之所以将这两个算法放在一起讲是因为它们的基本思想都是一样的，而单模式串匹配可以看做trie树只有一条链的情况

### 基本思想

充分利用一个串的后缀也可能是另一个串本身或它自己的前缀这一性质来解决问题

KMP能考到的问题并不多，因为是线性，大多都是继承这样的问题

### fail树

fail树的应用是两者的共同难点，但目前已知fail只有一个性质：

**以目前节点为结尾的字符串，是所有“以该节点的fail子节点为结尾的字符串”的后缀**

### 字符串DP

这才是最难的考点，但终究只是利用fail树和trie树来进行转移，其实难是难在DP本身，就把它当做纯粹的DP来做。

# Manacher算法总结

网上有关该算法的资源较少，该算法的受重视程度也较低

### 以i作为结尾（开头）的最长回文串长度

实现过程分为两步：先在算法过程中更新i作为“以某一点为中点的最长回文串”的边界的情况

**而接下来则是最关键的地方（只单方面考虑i作为结尾的情况）**

与上面相对的情况是i不作为“以某一点为中点的最长回文串”的边界，这意味着i在当前情况取得最优值时是处在某一回文串的内部。考虑i右边相邻的点j，j取得最优值时无论是否是边界，i利用j直接转移得到的都是不作为边界的值。此时再从反面证明，如果说此时i可以有一个在当前情况下比用j转移更优的值，那么这个值也自然能够去更新j的值（i处于某一回文串的内部，该回文串一定也包含了j，可以用i去更新j的值），这就与j已是最优值相矛盾，由此正确性得以证明。

### 因“双倍回文串”问题发现的算法极重要的性质

一种回文串可能在原串中出现多次，但一定会在它第一次出现的时候将pos设为它的中点，将mx设为它的边界。

证明：在任意时刻如果枚举到了某一个这种回文串的中点并且该回文串没有超出此时pos所对应回文串的边界，则在pos的左侧一定也出现过它。如果是第一次出现，那么左侧一定没有出现过它，则一定会超出边界，使得pos和mx改变。

![20170728171511046](D:\游家迪\Markdown文件\20170728171511046.bmp)

通过上图可以发现，**只有在mx更新的时候才有可能出现本质不同的回文串**，并由此发现一个性质：**一个字符串最多只有n个本质不同的回文子串**（这个性质目前很少有人发现或者总结出）

# CDQ分治

这是一个十分巧妙的算法

### 基本思想

1.我们要解决一系列问题，这些问题一般包含修改和查询操作，可以把这些问题排成一个序列，用一个区间$[L,R]$表示。

2.**分**。

递归处理左边区间$[L,M]$和右边区间$[M+1,R]$的问题。

3.**治**。

合并两个子问题，同时考虑到$[L,M]$内的修改对$[M+1,R]$内的查询产生的影响。即，用左边的子问题帮助解决右边的子问题。

**与普通分治不同点在于，普通分治在合并两个子问题的过程中，$[L,M]$内的问题不会对$[M+1,R]$内的问题产生影响。**

### 经典问题

#### 求解逆序对

利用当$[L,M]$，$[M+1,R]$都为升序排列时，若存在$i∈[L,M]$,$j∈[L,M]$,使得$i>j$,则可以确定$[i,M]$中的每个数都与$j$互为逆序对

#### 实现单点修改，区间查询

给定一个N个元素的序列a，初始值全部为0，对这个序列进行以下两种操作：

操作1：格式为1 x k，把位置x的元素加上k（位置从1标号到N）。操作2：格式为2 x y，求出区间[x,y]内所有元素的和。

我们把他转化成一个二维偏序问题，每个操作用一个有序对(a,b)表示，其中a表示操作到来的时间，b表示操作的位置，时间是默认有序的，所以我们在合并子问题的过程中，就按照b从小到大的顺序合并。

首先将区间查询操作都拆成两次前缀和查询，然后合并过程中考虑的就是左区间的修改操作对右区间的查询操作的影响，用一个sum来累加左区间已弹出的修改操作之和，在右边弹出一个查询操作时就可直接算左区间对它的贡献。

**注意**在位置相同时，左区间的修改操作依旧会对右区间的查询操作产生贡献，所以要先弹出修改操作来使sum累加上这个修改的值

# 二维偏序问题

### 问题描述

现在有多对区间$A_i,B_i$，询问对于一个有两个键值$a,b$的对象,有多少对区间使得$a∈A_i,b∈B_i$

### 分析

将A区间放在X轴上，将B区间放在Y轴上，将a,b看作坐标

一对区间就转化为了坐标系上的一个矩形，此时按X轴上左端点排序，从左往右对Y轴上的区间进行区间修改，遇到左边界加+1，遇到右边界-1，当遇到需要询问的点时，直接单点查询即可。

下图红色表示+1，蓝色表示-1（懒得画完）

![无标题 (2)](D:\游家迪\Markdown文件\无标题 (2).png)

# 点对的最长子序列问题

### 矩形包含

$(a,b)、(c,d)满足a<=b且c<=d$

对第一维排序，第二维用数据结构维护

### 连续不交错区间

$[a,b]、[c,d]满足b<=c$

方法一：对第二维排序然后使用贪心策略

方法二：对第一维排序然后第二维用数据机构维护（感觉很白痴的做法）

# 图论

### Prim算法

#### 原理

任意点所连接的最短边一定属于最小生成树$\longrightarrow$任意子树所连接的连向外部的最短边一定属于最小生成树

### 增量最小生成树

每次加入一条边如果成环就删掉环上最大边，目前只能每次dfs加倍增来找环上最大边

### 次小生成树

往最小生成树中加入一条边并删掉环上最大边

### 生成树计数

太过超前，日后填坑   

### 最小瓶颈生成树

#### 问题描述

给出加权无向图，求一棵最大边权值尽量小的生成树。

#### 分析

最小生成树一定是最小瓶颈树，因为将最小生成树上的任何一条边替换后都不会得到更优解

最小瓶颈树不一定是最小生成树，且最小瓶颈树可以有多颗

### 最小瓶颈路

#### 问题描述

给出加权无向图的两个结点u和v，求从u到v的一条路径，使得路径上权值最大的边的权值尽量小。

#### 分析

方法一：$O(m*\rm log_{2}d)$（d表示最大的边权的最大值）

二分+bfs，二分最大边的权值，bfs跑一遍看这样的最大边权是否可以找到一条从u到v的路径，离散化后复杂度为$O(\rm log_{2}m*m)$。

方法二：$O(m*\rm log_{2}m)$

Kruskal也是由于关心最大边，便同求“最小瓶颈生成树”一样思考，边排序后，当出现u到v的路径时，最后加入的边就是答案，不需要求完整颗生成树。因此最小瓶颈路便是最小生成树上的对应路径。

方法三：$O(n*\rm log_{2}n+2*m)$

遇到稠密图时需要采用prim算法，同样是在出现u到v的路径时，最后加入的边就是答案。

#### 补充

如果是对于所有点对都要求的话就只能$O(n^2)$

### 最小有向生成树-最小树形图-朱刘算法

#### 问题描述

给出加权有向图，求从某个点为根的，可以到达所有点的一个最小生成树。

#### 分析

在所有操作开始之前，需要把图中所有的自环全都清除。自环是不可能在任何一个树形图上的。只有进行了这步操作，总算法复杂度才真正能保证是$O(VE)$。

首先为除根之外的每个点选定一条入边，这条入边一定要是所有入边中最小的。现在所有的最小入边都选择出来了，如果这个入边集不存在有向环的话，这个集合就是该图的最小树形图。

如果存在有向环的话，就要将这个有向环缩成一个人工顶点，同时改变图中边的权。假设某点u在该环上，并设这个环中指向u的边权是in[u]，那么对于每条从u出发的边(u, i, w)，在新图中连接(new, i, w)的边，其中new为新加的人工顶点; 对于每条进入u的边(i, u, w)，在新图中建立边(i, new, w-in[u])的边。

现在依据上面的结论，说明一下为什么出边的权不变，入边的权要减去in [u]。对	于新图中的最小树形图T，设指向人工节点的边为e。将人工节点展开以后，e指向了一个环。假设原先e是指向u的，这个时候我们将环上指向u的边 in[u]删除，这样就得到了原图中的一个树形图。我们会发现，如果新图中e的权w'(e)是原图中e的权w(e)减去in[u]权的话，那么在我们删除 掉in[u]，并且将e恢复为原图状态的时候，这个树形图的权仍然是新图树形图的权加环的权，而这个权值正是最小树形图的权值。所以在展开节点之后，我们得到的仍然是最小树形图。逐步展开所有的人工节点，就会得到初始图的最小树形图了。

由于一开始已经拿掉了所有的自环，可知每个环至少包含2个点，收缩成1个点之后，总点数减少了至少1。当整个图收缩到只有1个点的时候，最小树形图就不用求了。所以最多只会进行V-1次的收缩，总复杂度自然是O(VE)。由此可见，如果一开始不除去自环的话，理论复杂度会和自环的数目有关。

![20150826092343443](D:\游家迪\Markdown文件\20150826092343443.jpg)

### 最小K度限制生成树

#### 问题描述

给出带权无向图，规定某一点v的度数不能超过k,求最小生成树

#### 分析

首先将v从原图中删去，然后对于剩下图中的每个联通块求最小生成树，如果求出的最小生成数个数超过k，即联通块个数超过k，原图就不存在该点的k度限制生成树。否则，加入v到每个连通分量的最短边，此时就得到了最小m度限制生成树，答案暂存为其权值和。

接下来将剩下的与v相连的边从小到大依次加入，进行增量最小生成树，直到生成树中v的度数为k或与v相连的边全部加入，这一过程中不断更新答案即可。

### 最优替换边

#### 问题描述

给出一个带权无向图，在保证其有最小生成树的前提下，改变最小生成树上的某一条边的权值，求此时最小生成树的值

#### 分析

先转有根树，重点在于**求点i到点j所在子树的最近距离**$f[i][j]$

$f[i][j]=min\{dis[i][j],min\{f[i][k]\}\}$

按dfs序从大到小的顺序去，保证更新$f[i][j]$时所有$f[i][k]$已经被更新

### 最小支配集

#### 问题描述

已知一颗树，可以标记一些节点，每个被标记的节点可以支配半径为r内的所有节点包括它本身，求最小的可以支配整棵树的点集。

#### 分析

这是一个困扰了我几个月的问题，每隔一段时间再回过头看都会有更深的理解

**1.贪心**

每次选择还没有被支配的最深的节点，标记它往上第r个节点。**重点在于如何判断一个点是否被支配**，只需要记录对于每个节点和其子树中离它最近的消防站的距离。对于一个未被支配的节点，就看它的上r位祖先自身以及其他子树里有没有可以支配到它的消防站。每标记一个节点就往上更新它的上r为祖先的最近距离。

**2.树形DP**

定义$f[i][j]和g[i][j]$分别表示一定能支配i及其子树并向上支配j个节点的最小代价和一定能支配i往下j层的所有节点及其子树最小代价

```
void dfs(int x)
{
    int i,j,y;
    if(vis[x])
	f[x][0]=g[x][0]=w[x];
    for(i=1;i<=D;i++)f[x][i]=w[x];
    f[x][D+1]=inf;
    for(i=head[x];i!=-1;i=next[i])
	if(to[i]!=fa[x])
    {
        y=to[i],fa[y]=x,dfs(y);
        for(j=D;j>=0;j--)
        f[x][j]=min(f[x][j]+g[y][j],g[x][j+1]+f[y][j+1]);
        for(j=D;j>=0;j--)f[x][j]=min(f[x][j],f[x][j+1]);
        g[x][0]=f[x][0];
        for(j=1;j<=D;j++)g[x][j]+=g[y][j-1];
        for(j=1;j<=D;j++)g[x][j]=min(g[x][j],g[x][j-1]);
    }
}
```

### 苗条生成树

#### 问题描述

求一颗生成树，满足最大边和最小边之差最小

#### 分析

对边排序后，枚举最小边然后求最小生成树，复杂度$O(m\rm log_{2}m+(m^2或m*n\rm log_{2}n))$

### 点—双连通分量

##### 定义

连通图满足中的任意两点之间至少有2条点不相同的路径的极大子图

##### 性质

任意两条边至少在同一个简单环上，这个可以利用定义证明

内部不存在割顶，因为由定义可知删除任意一点后，连通性不变

两个点双之间最多有一个公共点，该点一定为原图的割顶

一个割顶可以是多个点双的公共点

##### 算法实现

由上述性质可以得出点双的寻找过程就是寻找割顶，而保存点双要**保存边集**而非点集因为存在公共点

### 边—双连通分量

##### 定义

连通图中满足任意两点之间至少有两条边不相同的路径的极大子图

##### 性质

任意一条边一定在一个简单环上

内部不含桥

任意边双之间没有交点

##### 算法实现

找出所有的桥然后将桥删除后剩下的所有连通分量都是边双

##### 补充

无向图的缩点即是缩边双

# DFS序

### 定义

每个节点进出栈的时间序列

### 用途

可以将树的结构线性化

### 应用

##### 单点修改+单点查询

不要问这个问题。。。

##### 单点修改+子树查询

进栈时间序列

##### 单点修改+树链查询

进栈出栈时间序列维护差分前缀和

##### 子树修改+单点查询

进栈时间序列

##### 子树修改+子树查询

进栈时间序列

##### 子树修改+树链查询

##### 树链修改+单点查询

进栈时间序列，4次单点修改和一次区间查询

##### 树链修改+树链查询

##### 树链修改+子树查询

进栈时间序列，维护w[v]和w[v]*(dep[v]+1)的单点修改与区间求和 

# 组合数学

### 计数问题

![无标题](D:\游家迪\Markdown文件\无标题.png)

### *容斥原理



### 多重集

#### 多重集排列

可以轻松地理解到重复元素的排列会被重复计算，重复计算的个数满足乘法原理，所以最后把所有重复元素的排列数全部除去即可
$$
x=\frac{n!}{n_1!\ n_2!\ n_3!\dots n_k!}
$$

#### 多重集组合

多重集组合只会考虑选k个元素，且每种元素的数量都$\geqslant$k的情况

可以确定的是任意组合都呈现为$\left\{x_1*a_1,x_2*a_2\dots x_k*a_k\right\}$的形式，问题转化为求方程$x_1+x_2+\dots +x_k=k$的非负整数解的个数，就是一个简单的计数问题
$$
x=C_{n+k-1}^{k-1}
$$

### *组合数公式

# 离散概率论

### 重复递归的概率公式

$P(AB)=1-P(\overline{A}U\overline{B})=1-P(\overline{A})-P(\overline{B}) + P(\overline{A}\overline{B})$

$P(\overline{A}\overline{B})=1-P(A\bigcup B)=1-P(A)-P(B)+P(AB)$

发现上面两个式子在反复递归，理论上来讲是无法求的，但可以通过直接求出某一值来终止递归。

### 选举定理

观察所有可能的折线，发现可以直接由杨辉三角得出生成的折线有$C_{m+n}^{n}$条
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzNTUwMTQ1NzVdfQ==
-->