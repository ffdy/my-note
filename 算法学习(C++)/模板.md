## 字符串hash
```cpp 
#include<cstdio>
#include<algorithm>
#include<cstring>
#define ll unsigned long long 
using namespace std;
const int maxn=1e4+10;
char str[maxn];
ll ha[maxn],ans;
int n;
int prime=233317; 
ll mod=212370440130137957ll,base=233317;
ll hash(char str[])
{
	int l=strlen(str);
	ll bns=0;
	for(int i=0;i<l;i++) 
	bns=(bns*base+(ll)str[i])%mod+prime;
	return bns;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",str);
		ha[i]=hash(str);
	}
	sort(ha+1,ha+1+n);
	for(int i=1;i<=n;i++)
	if(ha[i]!=ha[i+1]) ans++;
	printf("%d\n",ans);
	return 0;
}
```
## 乘法逆元
```cpp  
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
const int maxn=3e6+10;
int n;
ll mod,inv[maxn];
int main()
{
	scanf("%d%lld",&n,&mod);
	inv[1]=1;printf("1\n");
	for(int i=2;i<=n;i++)
	{
		inv[i]=(mod-mod/i)*inv[mod%i]%mod;
		printf("%lld\n",inv[i]);
	}
	return 0;
}
```
## 最小生成树(Prim)
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=5e3+10,maxm=2e5+10;
int n,m,head[maxn],num,ans;
int dis[maxn];
struct fy{
	int to,d,next;
}q[maxm<<1];
bool use[maxn];
void add(int a,int b,int c){
	q[++num]=(fy){b,c,head[a]};head[a]=num;
}
void prime(){
	int t=n-1,a=1,w;
	memset(dis,0x3f,sizeof dis);
	while(t--){
		use[a]=true;
		for(int i=head[a];i;i=q[i].next){
			int b=q[i].to;
			if(!use[b]&&q[i].d<dis[b]){
				dis[b]=q[i].d;
			}
		}
		w=dis[0];
		for(int i=1;i<=n;i++){
			if(w>dis[i]&&!use[i]){
				a=i;w=dis[i];
			}
		}
		ans+=w;
	}
}
int main(){
	scanf("%d%d",&n,&m);int a,b,c;
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&a,&b,&c);
		add(a,b,c);add(b,a,c);
	}
	prime();
	printf("%d\n",ans);
	return 0;
}
```
## 快速幂
```cpp
#include<cstdio>
#include<algorithm>
#define ll long long
using namespace std;
//const int inf=1e9+7;
ll aa,bb,cc;
ll poww(ll a,ll b,ll c)
{
	ll ans=1,ba=a%c;
	while(b)
	{
		if(b&1) ans=ans*ba%c;
		ba=ba*ba%c;
		b>>=1;
	}
	return ans;
}
int main()
{
	scanf("%lld%lld%lld",&aa,&bb,&cc);
	printf("%lld^%lld mod %lld=%lld\n",aa,bb,cc,poww(aa,bb,cc)%cc);
	return 0;
}
```
## 二分图匹配
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=2e3+5;
int n,m,e;
int head[maxn],num;
struct fy{int from,to,next;}q[maxn*maxn];
bool use[maxn];
int p[maxn],ans;
bool find(int a)
{
	for(int i=head[a];i;i=q[i].next)
	{
		int b=q[i].to;
		if(!use[b])
		{
			use[b]=true;
			if(!p[b]||find(p[b]))
			{
				p[b]=a;
				return true;
			}
		}
	}
	return false;
}
int main()
{
	scanf("%d%d%d",&n,&m,&e);
	for(int i=1;i<=e;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		if(x<=n&&y<=m) 
		q[++num]=(fy){x,y,head[x]},head[x]=num;
	}
	for(int i=1;i<=n;i++)
	{
		memset(use,false,sizeof(use));
		if(find(i)) ans++;
	}
	printf("%d",ans);
	return 0;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE3NTQyNjQyMzddfQ==
-->